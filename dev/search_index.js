var documenterSearchIndex = {"docs":
[{"location":"GettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"GettingStarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This package is not yet listed in Julia and this section will thus be updated in the future. Please obtain the latest version of Julia from here. Next download the package zip file from GitHub and from the directory run julia in the Terminal. Next run,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"julia> ] activate .\n\njulia> ] instantiate","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This will install the required packages and also install the required Python packages via CondaPkg.jl.","category":"page"},{"location":"GettingStarted/#Generating-Multiplex-Graphs","page":"Getting Started","title":"Generating Multiplex Graphs","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"A multiplex graph can be supplied as a vector of Float64 matrices or by using the BlockGraph instance to build temporal networks.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"For example running the following,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"list = [0,2]\ndegrees = nothing\nη = 0.8\nclusters = nothing\nblock = BlockGraph(20, 15, list, η, clusters, degrees)\nW1 = block()","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"returns W1, a Vector{Matrix{Float64}} containing adjacency matries ordered in time corresponding to 20 vertices each with transition from unclustered to the emergence of two fully intraconnected clusters.","category":"page"},{"location":"GettingStarted/#Building-a-Temporal-Network","page":"Getting Started","title":"Building a Temporal Network","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The MultilayerGraph instance builds a temporal network using a connection rule, of type TemporalConnectivity. The default is Multiplex.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"mlgraph = MultilayerGraph(W1, connect = Multiplex())","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"One can visualize say the final layer using plot(mlgraph,17)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"GettingStarted/#Spectral-Partitions-and-SEBA","page":"Getting Started","title":"Spectral Partitions and SEBA","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The SpectralPartition and SEBAPartition are the most important instances that compute spectral partitions using supra-Laplacians and the SEBA algorithm.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"To compute a spectral partition simply run,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"partition = SpectralPartition(mlgraph)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This computes the supra-Laplacian mathbf L= mathbf L^rm spat + a^2 mathbf L^rm temp where the parameter a is computed by finding the point where the second spatial eigenvalue Lambda_2a^rm spat crosses the first temporal eigenvalue Lambda_1a^rm temp. This is the default case, one can also compute the exact same value using RayleighBalancing(2).","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The object partition contains the supra-Laplacian elements, the graph object mlgraph and the normalization for the Laplacian, which is IdentityNormalization() by default. Most importantly, it contains evecs and evals, which are ordered eigenvectors and eigenvalues respectively of the supra-Laplacian.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The infomation in partition is plotted using the plots command as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p1, p2 = plot(partition)\nplot(p1)\nplot(p2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: )","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The eigenvectors 2 and 4 store (corresponding to the first two nontrivial spatial eigenvectors) important information about the partition. The partition elements embedded in the eigenvectors evecs are disentangled using the SEBA algorithm as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"seba_part = SEBAPartition(partition,2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This automatically detects the leading two non-trivial spatial eigenvectors and runs SEBA on the corresponding eigenvectors. It computes the corresponding SEBA vectors and computes the corresponding Cheeger ratios stored in seba_part.cuts. The vectors can be plotted as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p1,p2 = plot(seba_part)\nplot(p1...)\nplot(p2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: )","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"We see that the first three SEBA vectors are meaninful, while the last vector corresponds to a very high Cheeger ratio. Thus this is discarded. Finally the network partition can be plotted as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"plot(seba_part, [1,2,3]) # 4 is removed as it is not meaningful","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"conts/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"conts/","page":"Index","title":"Index","text":"","category":"page"},{"location":"conts/","page":"Index","title":"Index","text":"Modules = [TemporalNetworks]","category":"page"},{"location":"conts/#TemporalNetworks.BlockGraph","page":"Index","title":"TemporalNetworks.BlockGraph","text":"BlockGraph(N :: Int64, T :: Int64, list :: Vector, η :: Float64, clusters :: Union{Nothing, Vector}, degrees :: Union{Nothing, Vector})\n\nMultiplex type block graph instance. Constructs a temporal network of N vertices per time slice with T time steps.\n\nThe transition types are encoded in list which is a Vector{Int64}. Numbers indicate number of disjoint clusters to be constructed at certain time points. clusters and degrees hold information about which vertices belong to which clusters and the cluster degrees respectively (the clusters are regular subgraphs). \n\nThe instance used as a function and passed with no arguments returns a sequence of adjacency matrices of type Vector{Float64}. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.BlockGraphNonMultiplex","page":"Index","title":"TemporalNetworks.BlockGraphNonMultiplex","text":"BlockGraphNonMultiplex(N :: Int64, T :: Int64, list :: Vector, η :: Float64, clusters :: Union{Nothing, Vector}, degrees :: Union{Nothing, Vector}, interaction :: IntraBlockConnectivity, evolve :: Int64)\n\nNon-multiplex type staircase graph instance. Constructs a temporal network of Nspatial vertices \\bigcup_{t=1}^T\\{x: (t,x)\\in\\mathcal{V}\\}withT` time steps. \n\nThe transition types are encoded in list which is a Vector{Int64}. Numbers indicate number of disjoint clusters to be constructed at certain time points. clusters and degrees hold information about which vertices belong to which clusters and the cluster degrees respectively (the clusters are regular subgraphs). \n\ninteraction is a IntraBlockConnectivity instance that acts as a function, and is applied to all intercluster edge weights. The default is ScalingConnectivity(T) which is the function x mapsto xT.  \n\nevolve indicates how many vertices per block are to be considered absent in the next layer, and switched with equally many new vertices from the absent ones. Defaults to 1.\n\nBlockGraphNonMultiplex(N, T, list, η, clusters, degrees)\n\nBlockGraphNonMultiplex instance with interactivity = ScalingConnectivity(2) and evolve=1.\n\nBlockGraphNonMultiplex(N, T, list, η, clusters, degrees)\n\nBlockGraphNonMultiplex instance with interactivity = ScalingConnectivity(2)\n\nThe instance used as a function and passed with no arguments returns a sequence of adjacency matrices of type Vector{Float64}. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.DegreeNormalization","page":"Index","title":"TemporalNetworks.DegreeNormalization","text":"(:: DegreeNormalization)(L :: Matrix)\n\nNormalizes Laplacian with resepct to the standard normalization D^-12LD^-12 where D is diagonal with i-th entry equal to deg(i). \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.IdentityNormalization","page":"Index","title":"TemporalNetworks.IdentityNormalization","text":"(:: IdentityNormalization)(L :: Matrix)\n\nTrivial Normalization of the Laplacian. Simply returns L. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.MultilayerGraph","page":"Index","title":"TemporalNetworks.MultilayerGraph","text":"MultilayerGraph{M <: TemporalConnectivity}(W :: Vector{Matrix{Float64}}; connect = Multiplex())\n\nThe temporal network instance. Stores sequence of adjacencies W, nodes per layer N, number of layers T and the connectivity of abstract type TemporalConnectivity. Default is Multiplex(), other options include NonMultiplexCompressed(). \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.Multiplex","page":"Index","title":"TemporalNetworks.Multiplex","text":"(:: Multiplex)(mlgraph :: MultilayerGraph)\n\nConnection type :: TemporalConnectivity for MultilayerGraph. Returns W_spat, W_temp such that Wˢᵖᵃᵗ = ᵢWⁱ and Wᵗᵉᵐᵖ = WIₙ. \n\nEquivalently,\n\nW_spat = directsum(mlgraph.W) where W :: Vector{Matrix}\nW_temp = kron(Wt, Matrix{Float64}(I, mlgraph.N, mlgraph.N)) where Wt is a T x T matrix describing how the layers are connected (symmetric supradiagonal).\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.NonMultiplexCompressed","page":"Index","title":"TemporalNetworks.NonMultiplexCompressed","text":"(:: NonMultiplexCompressed)(mlgraph :: MultilayerGraph)\n\nNonmultiplex connection type :: TemporalConnectivity for MultilayerGraph. Returns W_spat, W_temp such that:\n\nW_spat = directsum(mlgraph.W) where W :: Vector{Matrix}\nW_temp[i,j] ≂̸ 0 iff\nmlgraph.W[k][q,:] ≂̸ 0\nmlgraph.W[l][r,:] ≂̸ 0\nwhere (kq)  Rᴺ  Rᵀ and (lr)  Rᴺ  Rᵀ are the separated spacetime indices corresponding to i  Rᴺᵀ and j   Rᴺᵀ respectively.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.RayleighBalancing","page":"Index","title":"TemporalNetworks.RayleighBalancing","text":"RayleighBalancing(ind :: Int64)\n\nCreates DiffusionEstimator instance to compute the diffusion constant a for the supra-Laplacian arising from a non-multiplex network by matching the spatial and temproral Rayleigh quotient contributions with respect to the eigenvalue indexed by ind. \n\nRecommendeded for nonmultiplex networks. \n\n(rb:: RayleighBalancing)(mlgraph :: MultilayerGraph ,norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64})\n\nComputes the diffusion constant a using the Rayleigh balancing criterion. See [FroylandKaliaKoltai2024] for details on this heuristic.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SEBAPartition","page":"Index","title":"TemporalNetworks.SEBAPartition","text":"SEBAPartition{MG <: MultilayerGraph, N <: Normalization}(partition :: SpectralPartition, )\n\nSEBA partitiom instance. Stores the SpectralPartition instance in partition, supra-Laplacian eigenvector indices used in SEBA in inds, SEBA vectors in vecs and corresponding Cheeger ratios in cuts (depending on type of Normalization).\n\nSEBAPartition applies the SEBA algorithm to chosen/identified eigenvectors from partition.evecs and computes Cheeger rations.\n\nSEBAPartition(partition :: SpectralPartition, inds :: Vector{Int64})\n\nComputes SEBAPartition instance using partition.evecs[:, inds].\n\nSEBAPartition(partition :: SpectralPartition, max_ind :: Int64)\n\nComputes SEBAPartition instance by finding max_ind leading non-trivial spatial eigenvectors within partition.evecs. Does not work with NonMultiplex type graphs.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpatTempMatching","page":"Index","title":"TemporalNetworks.SpatTempMatching","text":"(:: SpatTempMatching)(::SpatTempMatching)(mlgraph :: MultilayerGraph{T}, norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64}) where T <: Multiplex\n\nComputes the diffusion constant a by matching the second spatial eigenvalue (first non-trivial spatial eigenvalue) to the first temporal eigenvalue for the supra-Laplacian corresponding to a multiplex temporal network. \n\nThe multiplex structure guarantees a unique smallest intersection point. See [FroylandKoltai2023] and [AtnipFroylandKoltai2024] for details on this heuristic. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpatTempMatchingNonMultiplex","page":"Index","title":"TemporalNetworks.SpatTempMatchingNonMultiplex","text":"SpatTempMatchingNonMultiplex(evec_ind :: Int64, temp_ind :: Union{Int64, Nothng}, thresh :: Float64)\n\nCreates DiffusionEstimator instance to compute the diffusion constant a for the supra-Laplacian arising from a non-multiplex network by matching the eigenvalue corresponding to evec_ind to the corresponding multiplex temporal eigenvalue with index temp_ind. \n\nThe parameter thresh is used by isspat(::MultilayerGraph{NonMultiplex}, ...) to check for spatial-like behaviour.\n\n(:: SpatTempMatchingNonMultiplex)(::SpatTempMatching)(mlgraph :: MultilayerGraph{T}, norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64}) where T <: NonMultiplex\n\nComputes the diffusion constant a using the matching heuristic for non-multiplex networks. See [FroylandKaliaKoltai2024] for details on this heuristic.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpectralPartition","page":"Index","title":"TemporalNetworks.SpectralPartition","text":"SpectralPartition{MG <: MultilayerGraph, N <: Normalization}(mlgraph :: MultilayerGraph; compute_a = SpatTempMatching(), norm = IdentityNormalization())\n\nSpectral partition instance for the temporal network defined by mlgraph :: MultilayerGraph. mlgraph is stored in graph, norm :: Normalization stores the Laplacian normalization function (default is IdentityNormalization()), a contains the diffusion constant, L_temp and L_spat are the temporal and spatial supra-Laplacians respectively and evecs and evals store the eigendata of the supra-Laplacian.\n\nSpectralPartition computes the supra-Laplacian mathbf L^(a) = mathbf L^rm spat + a^2 mathbf L^rm temp, computes the appropriate value of the diffusion constant a and computes the spectrum for both multiplex and nonmultiplex type networks.\n\nNote that for nonmultiplex networks, evecs are lifted to mathbb R^TN.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.bipartite_minimum_weight_edge_cover-Tuple{Any}","page":"Index","title":"TemporalNetworks.bipartite_minimum_weight_edge_cover","text":"Computes the minimum-weight edge cover of a bipartite graph G.  We assume there are m nodes on the left and n nodes on the right, where m≥n. The (i,j)th entry of the m×n matrix G contains the weight of the edge joining node i and node j. A binary m×n array is output, encoding the cover.\n\n\n\n\n\n","category":"method"},{"location":"conts/#TemporalNetworks.bisection-Tuple{Any, Real, Real}","page":"Index","title":"TemporalNetworks.bisection","text":"bisection(f, a, b; fa = f(a), fb = f(b), ftol, wtol)\n\nBisection algorithm for finding the root f(x)  0 within the initial bracket [a,b].\n\nReturns a named tuple (x = x, fx = f(x), isroot = ::Bool, iter = ::Int, ismaxiter = ::Bool).\n\nTerminates when either\n\nabs(f(x)) < ftol (isroot = true),\nthe width of the bracket is ≤wtol (isroot = true, to account for discontinuities),\nmaxiter number of iterations is reached. (isroot = false, maxiter = true).\n\nwhich are tested for in the above order. Therefore, care should be taken not to make wtol too large.\n\n\n\n\n\n","category":"method"},{"location":"#TemporalNetworks.jl","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"","category":"section"},{"location":"","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"TemporalNetworks.jl is a package that computes partitions of graphs/networks defined in spacetime. The networks are defined by a sequence Vector{Matrix{Float64}} of adjacency matrices. One can perform the following tasks:","category":"page"},{"location":"","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"Compute spectral partitions of multiplex and nonmultiplex spacetime graphs using appropriate supra-Laplacians.\nUse the Sparse Eigenbasis Algorithm to disentagle multiple partition elements from eigenvectors of the supra-Laplacian.\nPlot networks, partitions and compute corresponding Cheeger ratios.\nCompute and plot partitions using Leiden, a modularity maximisation algorithm via the python package leidenalg.","category":"page"}]
}
