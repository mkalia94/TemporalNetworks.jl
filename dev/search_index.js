var documenterSearchIndex = {"docs":
[{"location":"GettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"GettingStarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This package is not yet listed in Julia and this section will thus be updated in the future. Please obtain the latest version of Julia from here. Next download the package zip file from GitHub and from the directory run julia in the Terminal. Next run,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"julia> ] activate .\n\njulia> ] instantiate","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This will install the required packages and also install the required Python packages via CondaPkg.jl.","category":"page"},{"location":"GettingStarted/#Generating-Multiplex-Graphs","page":"Getting Started","title":"Generating Multiplex Graphs","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"A multiplex graph can be supplied as a vector of Float64 matrices or by using the BlockGraph instance to build temporal networks.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"TemporalNetworks.BlockGraph","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"For example running the following,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"list = [0,2]\ndegrees = nothing\nη = 0.8\nclusters = nothing\nblock = BlockGraph(20, 15, list, η, clusters, degrees)\nW1 = block()","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"returns W1, a Vector{Matrix{Float64}} containing adjacency matries ordered in time corresponding to 20 vertices each with transition from unclustered to the emergence of two fully intraconnected clusters.","category":"page"},{"location":"GettingStarted/#Building-a-Temporal-Network","page":"Getting Started","title":"Building a Temporal Network","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The MultilayerGraph instance builds a temporal network using a connection rule, of type TemporalConnectivity. The default is Multiplex.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"TemporalNetworks.MultilayerGraph","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"mlgraph = MultilayerGraph(W1, connect = Multiplex())","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"One can visualize say the final layer using plot(mlgraph,17)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"GettingStarted/#Spectral-Partitions-and-SEBA","page":"Getting Started","title":"Spectral Partitions and SEBA","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The SpectralPartition and SEBAPartition are the most important instances that compute spectral partitions using supra-Laplacians and the SEBA algorithm.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"TemporalNetworks.SpectralPartition\nTemporalNetworks.SEBAPartition","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"To compute a spectral partition simply run,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"partition = SpectralPartition(mlgraph)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This computes the supra-Laplacian mathbf L= mathbf L^rm spat + a^2 mathbf L^rm temp where the parameter a is computed by finding the point where the second spatial eigenvalue Lambda_2a^rm spat crosses the first temporal eigenvalue Lambda_1a^rm temp. This is the default case, one can also compute the exact same value using RayleighBalancing(2).","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The object partition contains the supra-Laplacian elements, the graph object mlgraph and the normalization for the Laplacian, which is IdentityNormalization() by default. Most importantly, it contains evecs and evals, which are ordered eigenvectors and eigenvalues respectively of the supra-Laplacian.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The infomation in partition is plotted using the plots command as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p1, p2 = plot(partition)\nplot(p1)\nplot(p2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: )","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The eigenvectors 2 and 4 store (corresponding to the first two nontrivial spatial eigenvectors) important information about the partition. The partition elements embedded in the eigenvectors evecs are disentangled using the SEBA algorithm as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"seba_part = SEBAPartition(partition,2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This automatically detects the leading two non-trivial spatial eigenvectors and runs SEBA on the corresponding eigenvectors. It computes the corresponding SEBA vectors and computes the corresponding Cheeger ratios stored in seba_part.cuts. The vectors can be plotted as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p1,p2 = plot(seba_part)\nplot(p1...)\nplot(p2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: )","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"We see that the first three SEBA vectors are meaninful, while the last vector corresponds to a very high Cheeger ratio. Thus this is discarded. Finally the network partition can be plotted as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"plot(seba_part, [1,2,3]) # 4 is removed as it is not meaningful","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"conts/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"conts/","page":"Index","title":"Index","text":"","category":"page"},{"location":"conts/","page":"Index","title":"Index","text":"Modules = [TemporalNetworks]","category":"page"},{"location":"conts/#TemporalNetworks.DegreeNormalization","page":"Index","title":"TemporalNetworks.DegreeNormalization","text":"(:: DegreeNormalization)(L :: Matrix)\n\nNormalizes Laplacian with resepct to the standard normalization D^-12LD^-12 where D is diagonal with i-th entry equal to deg(i). \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.IdentityNormalization","page":"Index","title":"TemporalNetworks.IdentityNormalization","text":"(:: IdentityNormalization)(L :: Matrix)\n\nTrivial Normalization of the Laplacian. Simply returns L. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.Multiplex","page":"Index","title":"TemporalNetworks.Multiplex","text":"(:: Multiplex)(mlgraph :: MultilayerGraph)\n\nConnection type :: TemporalConnectivity for MultilayerGraph. Returns W_spat, W_temp such that Wˢᵖᵃᵗ = ᵢWⁱ and Wᵗᵉᵐᵖ = WIₙ. \n\nEquivalently,\n\nW_spat = directsum(mlgraph.W) where W :: Vector{Matrix}\nW_temp = kron(Wt, Matrix{Float64}(I, mlgraph.N, mlgraph.N)) where Wt is a T x T matrix describing how the layers are connected (symmetric supradiagonal).\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.NonMultiplexCompressed","page":"Index","title":"TemporalNetworks.NonMultiplexCompressed","text":"(:: NonMultiplexCompressed)(mlgraph :: MultilayerGraph)\n\nNonmultiplex connection type :: TemporalConnectivity for MultilayerGraph. Returns W_spat, W_temp such that:\n\nW_spat = directsum(mlgraph.W) where W :: Vector{Matrix}\nW_temp[i,j] ≂̸ 0 iff\nmlgraph.W[k][q,:] ≂̸ 0\nmlgraph.W[l][r,:] ≂̸ 0\nwhere (kq)  Rᴺ  Rᵀ and (lr)  Rᴺ  Rᵀ are the separated spacetime indices corresponding to i  Rᴺᵀ and j   Rᴺᵀ respectively.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.RayleighBalancing","page":"Index","title":"TemporalNetworks.RayleighBalancing","text":"RayleighBalancing(ind :: Int64)\n\nCreates DiffusionEstimator instance to compute the diffusion constant a for the supra-Laplacian arising from a non-multiplex network by matching the spatial and temproral Rayleigh quotient contributions with respect to the eigenvalue indexed by ind. \n\nRecommendeded for nonmultiplex networks. \n\n(rb:: RayleighBalancing)(mlgraph :: MultilayerGraph ,norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64})\n\nComputes the diffusion constant a using the Rayleigh balancing criterion. See [FroylandKaliaKoltai2024] for details on this heuristic.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpatTempMatching","page":"Index","title":"TemporalNetworks.SpatTempMatching","text":"(:: SpatTempMatching)(::SpatTempMatching)(mlgraph :: MultilayerGraph{T}, norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64}) where T <: Multiplex\n\nComputes the diffusion constant a by matching the second spatial eigenvalue (first non-trivial spatial eigenvalue) to the first temporal eigenvalue for the supra-Laplacian corresponding to a multiplex temporal network. \n\nThe multiplex structure guarantees a unique smallest intersection point. See [FroylandKoltai2023] and [AtnipFroylandKoltai2024] for details on this heuristic. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpatTempMatchingNonMultiplex","page":"Index","title":"TemporalNetworks.SpatTempMatchingNonMultiplex","text":"SpatTempMatchingNonMultiplex(evec_ind :: Int64, temp_ind :: Union{Int64, Nothng}, thresh :: Float64)\n\nCreates DiffusionEstimator instance to compute the diffusion constant a for the supra-Laplacian arising from a non-multiplex network by matching the eigenvalue corresponding to evec_ind to the corresponding multiplex temporal eigenvalue with index temp_ind. \n\nThe parameter thresh is used by isspat(::MultilayerGraph{NonMultiplex}, ...) to check for spatial-like behaviour.\n\n(:: SpatTempMatchingNonMultiplex)(::SpatTempMatching)(mlgraph :: MultilayerGraph{T}, norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64}) where T <: NonMultiplex\n\nComputes the diffusion constant a using the matching heuristic for non-multiplex networks. See [FroylandKaliaKoltai2024] for details on this heuristic.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.bipartite_minimum_weight_edge_cover-Tuple{Any}","page":"Index","title":"TemporalNetworks.bipartite_minimum_weight_edge_cover","text":"Computes the minimum-weight edge cover of a bipartite graph G.  We assume there are m nodes on the left and n nodes on the right, where m≥n. The (i,j)th entry of the m×n matrix G contains the weight of the edge joining node i and node j. A binary m×n array is output, encoding the cover.\n\n\n\n\n\n","category":"method"},{"location":"conts/#TemporalNetworks.bisection-Tuple{Any, Real, Real}","page":"Index","title":"TemporalNetworks.bisection","text":"bisection(f, a, b; fa = f(a), fb = f(b), ftol, wtol)\n\nBisection algorithm for finding the root f(x)  0 within the initial bracket [a,b].\n\nReturns a named tuple (x = x, fx = f(x), isroot = ::Bool, iter = ::Int, ismaxiter = ::Bool).\n\nTerminates when either\n\nabs(f(x)) < ftol (isroot = true),\nthe width of the bracket is ≤wtol (isroot = true, to account for discontinuities),\nmaxiter number of iterations is reached. (isroot = false, maxiter = true).\n\nwhich are tested for in the above order. Therefore, care should be taken not to make wtol too large.\n\n\n\n\n\n","category":"method"},{"location":"#TemporalNetworks.jl","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"","category":"section"},{"location":"","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"TemporalNetworks.jl is a package that computes partitions of graphs/networks defined in spacetime. The networks are defined by a sequence Vector{Matrix{Float64}} of adjacency matrices. One can perform the following tasks:","category":"page"},{"location":"","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"Compute spectral partitions of multiplex and nonmultiplex spacetime graphs using appropriate supra-Laplacians.\nUse the Sparse Eigenbasis Algorithm to disentagle multiple partition elements from eigenvectors of the supra-Laplacian.\nPlot networks, partitions and compute corresponding Cheeger ratios.\nCompute and plot partitions using Leiden, a modularity maximisation algorithm via the python package leidenalg.","category":"page"}]
}
