var documenterSearchIndex = {"docs":
[{"location":"Senator/#Real-world-example:-network-of-US-senators","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"","category":"section"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"This elaborated example can be found as a Pluto notebook in the PaperExamples branch under senator/senator_nb.jl.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"In WPF+09 and MRM+10 a network of senators was analyzed to understand party polarisation across time in the US Senate. We analyse the same network here in detail to discover communities that vary in time. The network data was collected from here.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"The network describes voting patterns between US senators/states. Each vertex corresponds to either a single senator or state, and the edge weight between any two vertices describes the voting similarity between the vertices, and lies in 01. More details can be found in WPF+09.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"Here we analyse the networks from the 100-100th congress, or the years 1987-2009.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"From the CSV files obtained, one can generate adjacency matrices using the files provided in the PaperExamples branch under senator/raw_data/build_dataset.jl.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"We start by loading important packages,","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"using TemporalNetworks, Plots, FileIO, JLD2","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"The file senator/raw_data/build_dataset.jl generates two collections of adjacency matrices, one each corresponding to the network of US senators and a network of US states. We load them, their labels (party affiliations/state names) and construct the MultilayerGraph and SpectralPartition instances. Note that the network of senators is nonmultiplex, while the state network is multiplex.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"W = FileIO.load(\"senator.jld2\",\"W\")\nlabels_party = FileIO.load(\"senator.jld2\",\"labels_party\")\nlabels_state = FileIO.load(\"senator.jld2\",\"labels_state\")\n\nmlgraph= MultilayerGraph(W, connect = NonMultiplexCompressed())\npartition = SpectralPartition(mlgraph, compute_a = RayleighBalancing(2))\n\nW_state = FileIO.load(\"state.jld2\", \"W\");\nlab_statelist = FileIO.load(\"state.jld2\", \"labels\");\nmlgraph_state = MultilayerGraph(W_state);\npartition_state = SpectralPartition(mlgraph_state)","category":"page"},{"location":"Senator/#The-Senator-network","page":"Real world example: network of US senators","title":"The Senator network","text":"","category":"section"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"We plot eigenvectors of the inflated dynamic Laplacian with respect to the senator network to select vectors which will induce the desired spacetime partition. ","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"h = plot(partition); plot(h[1][1:4]...)","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"(Image: )","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"Clearly eigenvector 3 is the first \"spatial\" eigenvector, which we use to construct the spacetime Laplacian. First, we carefully reorder vertices according to their temporal mean values, for visual convenience.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"evec_crit = reshape(partition.evecs[:,3],mlgraph.N, mlgraph.T)\nsens = find_active(mlgraph)\n\nlengths = zeros(mlgraph.N)\nfor i in 1:mlgraph.N\n    ctr = 0\n    for x in sens\n        ind = findall(y->y==i,x)\n        ctr += length(ind)\n    end\n    lengths[i] = ctr\nend\n\naa = sum(hcat([evec_crit[:,i] for i in 1:mlgraph.T]...), dims=2) ./ lengths\nv = sortperm(aa, dims=1)[:,1]\nordering = vcat([v .+ (i-1)*mlgraph.N for i in 1:mlgraph.T]...)","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"We now use v and ordering from the previous cell to reorder eigenvectors, labels and the network adjacencies appropriately.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"partition.evecs = partition.evecs[ordering, :]\nlab_party = labels_party[v]\nlab_state = labels_state[v]\nmlgraph.W = [x[v,v] for x in mlgraph.W]","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"We do a small preprocessing step for the party affiliations.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"for i in 1:mlgraph.N\n    if lab_party[i] == 328\n        lab_party[i] = 0\n    elseif lab_party[i] == 100\n        lab_party[i] = 1\n    elseif lab_party[i] == 200\n        lab_party[i] = -1\n    end\nend","category":"page"},{"location":"Senator/#State-network","page":"Real world example: network of US senators","title":"State network","text":"","category":"section"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"Next, similar to the senator case, we plot eigenvectors of the inflated dynamic Laplacian corresponding to the state network.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"h_state = plot(partition_state); plot(h_state[1][1:4]...)","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"(Image: )","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"Clearly the first spatial eigenvector is the second one (note that this is a multiplex network as opposed to the senator case). Thus we use the second eigenvector for spectral partitioning. We reorder the state vertices as well, by the magnitude of the eigenvector at the last time step.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"evec_crit_state = reshape(partition_state.evecs[:,2],partition_state.graph.N, partition_state.graph.T)\nv_state = sortperm(evec_crit_state[:,end])","category":"page"},{"location":"Senator/#Comparing-results-from-the-senator-and-state-network","page":"Real world example: network of US senators","title":"Comparing results from the senator and state network","text":"","category":"section"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"So how do these two networks compare? The state network is an aggregate of voting similarities of different senators belonging to the same state. For each state, we have two senators per congress (two years, one time step). ","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"Thus we compute the projection of the third eigenvector of the senator network onto the state network. This is done by finding the two senators corresponding to each state per time step, and assigning them the value obtained from the senator network eigenvector.","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"evecs_temp = [reshape(partition.evecs[:,3], mlgraph.N, mlgraph.T),]\nsens_ = find_active(mlgraph) \nstate_proj = [zeros(2*length(lab_statelist[v_state]), partition.graph.T) for i in 1:length(evecs_temp)]\nfor i in 1:length(state_proj)\n    for x in 1:length(lab_statelist[v_state]), y in 1:size(state_proj[i])[2]\n        ind_ = findall(z->(z ∈ sens_[y] && lab_state[z] == lab_statelist[v_state][x]), 1:partition.graph.N)\n        if length(ind_)==1\n            state_proj[i][(x-1)*2+1,y] = evecs_temp[i][ind_[1],y]\n        else\n            state_proj[i][(x-1)*2+1:2*x,y] = evecs_temp[i][ind_[1:2], y]\n            # None of this accounts for states that may have more than two senators in a single congress (with incomplete terms)\n        end\n    end\nend\n# Filter\nfor i in 1:length(state_proj)\n    for (j,x) in enumerate(state_proj[i])\n        if x == 0.0\n            state_proj[i][j] = NaN\n        end\n    end\nend\nstate_proj\n\nstate_proj[1] .*= sqrt(200);\npartition_state.evecs .*= sqrt(200);","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"state_proj contains the projection of senator results on to the network of states. We finally plot the results,","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"labelss = vcat([[x; \"\"] for x in lab_statelist[v_state]]...);\n\nh1 = heatmap(reshape(-partition_state.evecs[:,2],mlgraph_state.N,mlgraph_state.T)[v_state,:], c=cgrad(:RdBu), size=(600,800), yticks=(1:50,lab_statelist[v_state]), xticks=(1:2:11,1987:4:2009), dpi=300, clims = (-1,1))\n\nh2 = heatmap(state_proj[1], c=cgrad(:RdBu), size=(600,800), yticks=(1:100,labelss), xticks=(1:2:11,1987:4:2009), dpi=300, grid=false, clims=(-1,1))\n\nhline!(h2,0.5:2.0:(101+0.5), c=:black, labels=\"\", lw=1)\n\nplot(h1, h2, size=(900,700))","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"(Image: )","category":"page"},{"location":"Senator/","page":"Real world example: network of US senators","title":"Real world example: network of US senators","text":"The state and senator networks show a \"fading-in\" of polarisation as time passes. Note that the red-blue split is exactly along party lines.","category":"page"},{"location":"GettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"GettingStarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This package is not yet listed in Julia and this section will thus be updated in the future. Please obtain the latest version of Julia from here. Next download the package zip file from GitHub and from the directory run julia in the Terminal. Next run,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"julia> ] activate .\n\njulia> ] instantiate","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This will install the required packages and also install the required Python packages via CondaPkg.jl.","category":"page"},{"location":"GettingStarted/#Generating-Multiplex-Graphs","page":"Getting Started","title":"Generating Multiplex Graphs","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"A multiplex graph can be supplied as a vector of Float64 matrices or by using the BlockGraph instance to build temporal networks.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Here is a simple example that constructs and analyses a simple multiplex graph,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using TemporalNetworks\nlist = [0,2]\nη = 0.8\nclusters = [[Array(1:20)], \n            [Array(1:10), Array(11:15), Array(16:20)] ]\ndegrees = [[14],\n           [5,4,4]]\nblock = BlockGraph(20, 15, list, η, clusters, degrees)\nW1 = block()","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"block() returns W1, a Vector{Matrix{Float64}} containing adjacency matries ordered in time corresponding to 20 vertices each with transition from unclustered to the emergence of two fully intraconnected clusters.","category":"page"},{"location":"GettingStarted/#Building-a-Temporal-Network","page":"Getting Started","title":"Building a Temporal Network","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The MultilayerGraph instance builds a temporal network using a connection rule, of type TemporalConnectivity. The default is Multiplex.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"mlgraph = MultilayerGraph(W1, connect = Multiplex())","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"One can visualize say the final layer using plot(mlgraph,17)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"GettingStarted/#Spectral-Partitions-and-SEBA","page":"Getting Started","title":"Spectral Partitions and SEBA","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The SpectralPartition and SEBAPartition are the most important instances that compute spectral partitions using supra-Laplacians and the SEBA algorithm.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"To compute a spectral partition simply run,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"partition = SpectralPartition(mlgraph)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This computes the supra-Laplacian mathbf L= mathbf L^rm spat + a^2 mathbf L^rm temp where the parameter a is computed by finding the point where the second spatial eigenvalue Lambda_2a^rm spat crosses the first temporal eigenvalue Lambda_1a^rm temp. This is the default case, one can also compute the exact same value using RayleighBalancing(2).","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The object partition contains the supra-Laplacian elements, the graph object mlgraph and the normalization for the Laplacian, which is IdentityNormalization() by default. Most importantly, it contains evecs and evals, which are ordered eigenvectors and eigenvalues respectively of the supra-Laplacian.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The infomation in partition is plotted using the plots command as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p1, p2 = plot(partition)\nplot(p1)\nplot(p2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: )","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The eigenvectors 2 and 4 store (corresponding to the first two nontrivial spatial eigenvectors) important information about the partition. The partition elements embedded in the eigenvectors evecs are disentangled using the SEBA algorithm as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"seba_part = SEBAPartition(partition,2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This automatically detects the leading two non-trivial spatial eigenvectors and runs SEBA on the corresponding eigenvectors. It computes the corresponding SEBA vectors and computes the corresponding Cheeger ratios stored in seba_part.cuts. The vectors can be plotted as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p1,p2 = plot(seba_part)\nplot(p1...)\nplot(p2)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: )","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"We see that the first three SEBA vectors are meaninful, while the last vector corresponds to a very high Cheeger ratio. Thus this is discarded. Finally the network partition can be plotted as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"plot(seba_part, [1,2,3]) # 4 is removed as it is not meaningful","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"GettingStarted/#Comparison-with-existing-methods","page":"Getting Started","title":"Comparison with existing methods","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The Leiden algorithm can be called from the Python package leidenalg via PyCall as follows,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"leiden_partition = leiden_slice(partition)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This calls the Leiden algorithm on partition.graph and computes a slice-by-slice Leiden partition, which is stitched together by solving the minimum edge-weight cover problem on the super graph of clusters. Finally, the Leiden partition is plotted using,","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"heatmap(leiden_partition[2], c=cgrad([:white, :orange, :red]), size=(400,300), dpi=300)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"conts/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"conts/","page":"Index","title":"Index","text":"","category":"page"},{"location":"conts/","page":"Index","title":"Index","text":"Modules = [TemporalNetworks]","category":"page"},{"location":"conts/#TemporalNetworks.BlockGraph","page":"Index","title":"TemporalNetworks.BlockGraph","text":"BlockGraph(N :: Int64, T :: Int64, list :: Vector, η :: Float64, clusters :: Union{Nothing, Vector}, degrees :: Union{Nothing, Vector})\n\nMultiplex type block graph instance. Constructs a temporal network of N vertices per time slice with T time steps.\n\nThe transition types are encoded in list which is a Vector{Int64}. Numbers indicate number of disjoint clusters to be constructed at certain time points. clusters and degrees hold information about which vertices belong to which clusters and the cluster degrees respectively (the clusters are regular subgraphs). \n\nThe instance used as a function and passed with no arguments returns a sequence of adjacency matrices of type Vector{Float64}. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.BlockGraphNonMultiplex","page":"Index","title":"TemporalNetworks.BlockGraphNonMultiplex","text":"BlockGraphNonMultiplex(N :: Int64, T :: Int64, list :: Vector, η :: Float64, clusters :: Union{Nothing, Vector}, degrees :: Union{Nothing, Vector}, interaction :: IntraBlockConnectivity, evolve :: Int64)\n\nNon-multiplex type staircase graph instance. Constructs a temporal network of Nspatial vertices bigcup_t=1^Tx (tx)inmathcalV with T time steps. \n\nThe transition types are encoded in list which is a Vector{Int64}. Numbers indicate number of disjoint clusters to be constructed at certain time points. clusters and degrees hold information about which vertices belong to which clusters and the cluster degrees respectively (the clusters are regular subgraphs). \n\ninteraction is a IntraBlockConnectivity instance that acts as a function, and is applied to all intercluster edge weights. The default is ScalingConnectivity(T) which is the function x mapsto xT.  \n\nevolve indicates how many vertices per block are to be considered absent in the next layer, and switched with equally many new vertices from the absent ones. Defaults to 1.\n\nBlockGraphNonMultiplex(N, T, list, η, clusters, degrees)\n\nBlockGraphNonMultiplex instance with interactivity = ScalingConnectivity(2) and evolve=1.\n\nBlockGraphNonMultiplex(N, T, list, η, clusters, degrees)\n\nBlockGraphNonMultiplex instance with interactivity = ScalingConnectivity(2)\n\nThe instance used as a function and passed with no arguments returns a sequence of adjacency matrices of type Vector{Float64}. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.DegreeNormalization","page":"Index","title":"TemporalNetworks.DegreeNormalization","text":"(:: DegreeNormalization)(L :: Matrix)\n\nNormalizes Laplacian with resepct to the standard normalization D^-12LD^-12 where D is diagonal with i-th entry equal to deg(i). \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.IdentityNormalization","page":"Index","title":"TemporalNetworks.IdentityNormalization","text":"(:: IdentityNormalization)(L :: Matrix)\n\nTrivial Normalization of the Laplacian. Simply returns L. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.MultilayerGraph","page":"Index","title":"TemporalNetworks.MultilayerGraph","text":"MultilayerGraph{M <: TemporalConnectivity}(W :: Vector{Matrix{Float64}}; connect = Multiplex())\n\nThe temporal network instance. Stores sequence of adjacencies W, nodes per layer N, number of layers T and the connectivity of abstract type TemporalConnectivity. Default is Multiplex(), other options include NonMultiplexCompressed(). \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.Multiplex","page":"Index","title":"TemporalNetworks.Multiplex","text":"(:: Multiplex)(mlgraph :: MultilayerGraph)\n\nConnection type :: TemporalConnectivity for MultilayerGraph. Returns W_spat, W_temp such that Wˢᵖᵃᵗ = ᵢWⁱ and Wᵗᵉᵐᵖ = WIₙ. \n\nEquivalently,\n\nW_spat = directsum(mlgraph.W) where W :: Vector{Matrix}\nW_temp = kron(Wt, Matrix{Float64}(I, mlgraph.N, mlgraph.N)) where Wt is a T x T matrix describing how the layers are connected (symmetric supradiagonal).\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.NonMultiplexCompressed","page":"Index","title":"TemporalNetworks.NonMultiplexCompressed","text":"(:: NonMultiplexCompressed)(mlgraph :: MultilayerGraph)\n\nNonmultiplex connection type :: TemporalConnectivity for MultilayerGraph. Returns W_spat, W_temp such that:\n\nW_spat = directsum(mlgraph.W) where W :: Vector{Matrix}\nW_temp[i,j] ≂̸ 0 iff\nmlgraph.W[k][q,:] ≂̸ 0\nmlgraph.W[l][r,:] ≂̸ 0\nwhere (kq)  Rᴺ  Rᵀ and (lr)  Rᴺ  Rᵀ are the separated spacetime indices corresponding to i  Rᴺᵀ and j   Rᴺᵀ respectively.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.RayleighBalancing","page":"Index","title":"TemporalNetworks.RayleighBalancing","text":"RayleighBalancing(ind :: Int64)\n\nCreates DiffusionEstimator instance to compute the diffusion constant a for the supra-Laplacian arising from a non-multiplex network by matching the spatial and temproral Rayleigh quotient contributions with respect to the eigenvalue indexed by ind. \n\nRecommendeded for nonmultiplex networks. \n\n(rb:: RayleighBalancing)(mlgraph :: MultilayerGraph ,norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64})\n\nComputes the diffusion constant a using the Rayleigh balancing criterion. See [FroylandKaliaKoltai2024] for details on this heuristic.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SEBAPartition","page":"Index","title":"TemporalNetworks.SEBAPartition","text":"SEBAPartition{MG <: MultilayerGraph, N <: Normalization}(partition :: SpectralPartition, )\n\nSEBA partitiom instance. Stores the SpectralPartition instance in partition, supra-Laplacian eigenvector indices used in SEBA in inds, SEBA vectors in vecs and corresponding Cheeger ratios in cuts (depending on type of Normalization).\n\nSEBAPartition applies the SEBA algorithm to chosen/identified eigenvectors from partition.evecs and computes Cheeger rations.\n\nSEBAPartition(partition :: SpectralPartition, inds :: Vector{Int64})\n\nComputes SEBAPartition instance using partition.evecs[:, inds].\n\nSEBAPartition(partition :: SpectralPartition, max_ind :: Int64)\n\nComputes SEBAPartition instance by finding max_ind leading non-trivial spatial eigenvectors within partition.evecs. Does not work with NonMultiplex type graphs.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpatTempMatching","page":"Index","title":"TemporalNetworks.SpatTempMatching","text":"(:: SpatTempMatching)(::SpatTempMatching)(mlgraph :: MultilayerGraph{T}, norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64}) where T <: Multiplex\n\nComputes the diffusion constant a by matching the second spatial eigenvalue (first non-trivial spatial eigenvalue) to the first temporal eigenvalue for the supra-Laplacian corresponding to a multiplex temporal network. \n\nThe multiplex structure guarantees a unique smallest intersection point. See [FroylandKoltai2023] and [AtnipFroylandKoltai2024] for details on this heuristic. \n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpatTempMatchingNonMultiplex","page":"Index","title":"TemporalNetworks.SpatTempMatchingNonMultiplex","text":"SpatTempMatchingNonMultiplex(evec_ind :: Int64, temp_ind :: Union{Int64, Nothng}, thresh :: Float64)\n\nCreates DiffusionEstimator instance to compute the diffusion constant a for the supra-Laplacian arising from a non-multiplex network by matching the eigenvalue corresponding to evec_ind to the corresponding multiplex temporal eigenvalue with index temp_ind. \n\nThe parameter thresh is used by isspat(::MultilayerGraph{NonMultiplex}, ...) to check for spatial-like behaviour.\n\n(:: SpatTempMatchingNonMultiplex)(::SpatTempMatching)(mlgraph :: MultilayerGraph{T}, norm :: Normalization, L_spat :: Matrix{Float64}, L_temp :: Matrix{Float64}) where T <: NonMultiplex\n\nComputes the diffusion constant a using the matching heuristic for non-multiplex networks. See [FroylandKaliaKoltai2024] for details on this heuristic.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.SpectralPartition","page":"Index","title":"TemporalNetworks.SpectralPartition","text":"SpectralPartition{MG <: MultilayerGraph, N <: Normalization}(mlgraph :: MultilayerGraph; compute_a = SpatTempMatching(), norm = IdentityNormalization())\n\nSpectral partition instance for the temporal network defined by mlgraph :: MultilayerGraph. mlgraph is stored in graph, norm :: Normalization stores the Laplacian normalization function (default is IdentityNormalization()), a contains the diffusion constant, L_temp and L_spat are the temporal and spatial supra-Laplacians respectively and evecs and evals store the eigendata of the supra-Laplacian.\n\nSpectralPartition computes the supra-Laplacian mathbf L^(a) = mathbf L^rm spat + a^2 mathbf L^rm temp, computes the appropriate value of the diffusion constant a and computes the spectrum for both multiplex and nonmultiplex type networks.\n\nNote that for nonmultiplex networks, evecs are lifted to mathbb R^TN.\n\n\n\n\n\n","category":"type"},{"location":"conts/#TemporalNetworks.bipartite_minimum_weight_edge_cover-Tuple{Any}","page":"Index","title":"TemporalNetworks.bipartite_minimum_weight_edge_cover","text":"Computes the minimum-weight edge cover of a bipartite graph G.  We assume there are m nodes on the left and n nodes on the right, where m≥n. The (i,j)th entry of the m×n matrix G contains the weight of the edge joining node i and node j. A binary m×n array is output, encoding the cover.\n\n\n\n\n\n","category":"method"},{"location":"conts/#TemporalNetworks.bisection-Tuple{Any, Real, Real}","page":"Index","title":"TemporalNetworks.bisection","text":"bisection(f, a, b; fa = f(a), fb = f(b), ftol, wtol)\n\nBisection algorithm for finding the root f(x)  0 within the initial bracket [a,b].\n\nReturns a named tuple (x = x, fx = f(x), isroot = ::Bool, iter = ::Int, ismaxiter = ::Bool).\n\nTerminates when either\n\nabs(f(x)) < ftol (isroot = true),\nthe width of the bracket is ≤wtol (isroot = true, to account for discontinuities),\nmaxiter number of iterations is reached. (isroot = false, maxiter = true).\n\nwhich are tested for in the above order. Therefore, care should be taken not to make wtol too large.\n\n\n\n\n\n","category":"method"},{"location":"NonMultiplex/#Nonmultiplex-temporal-networks","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"","category":"section"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"In the previous section we looked at spectral partitions of multiplex networks. The same instances can be extended to nonmultiplex types. Here an example of a staircase graph is presented, which is non-multiplex in nature and can be constructed via the BlockGraphNonMultiplex instance as follows,","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"η = 0.8\nlist = [2,1]\nclusters = [[Array(1:5), Array(6:20), Array(21:25)],\n                [Array(1:10), Array(11:20)]] # you can ignore this line\ndegrees = [[4,6,4],\n        [6,6]] # Ignore this line\nevolve = 1\nblock = BlockGraphNonMultiplex(25, 10, list, η, clusters, degrees, evolve)\nW2 = block() |> Vector{Matrix{Float64}}","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"The network consists of 25 spatial vertices. The set of spatial vertices hat mathcal V = bigcup_t=1^Tx (tx)inmathcalV where mathcal V is the set of spacetime vertices present in the nonmultiplex network. The network has 10 time steps.","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"One then uses the instances MultilayerGraph, SpectralPartition and SEBAPartition to construct and analyse spacetime partitions. These functions naturally extend to nonmultiplex network types.","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"note: Note\nTo compute spectral partitions using SpectralPartition, one must compute the diffusion parameter a, which is done by default using SpatTempMatching. Although this may also work with nonmultiplex networks, it is advisable to use RayleighBalancing(x) where x is an appropriately chosen eigenvalue index for Rayleigh balancing.","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"mlgraph_nonmultiplex = MultilayerGraph(W2, connect = NonMultiplexCompressed())\npartition_nonmultiplex = SpectralPartition(mlgraph_nonmultiplex, compute_a = RayleighBalancing(3)) # Rayleigh balancing on third eigenvalue\nseba_part_nonmultiplex = SEBAPartition(partition_nonmultiplex,[2,])","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"Similar to before, one can plot eigenvectors, eigenvalues and SEBA vectors.","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"plot(plot(partition_nonmultiplex)[1][1:6]...)\nplot(plot(partition_nonmultiplex)[2])\nplot(plot(seba_part_nonmultiplex)...)","category":"page"},{"location":"NonMultiplex/","page":"Nonmultiplex temporal networks","title":"Nonmultiplex temporal networks","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"#TemporalNetworks.jl","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"","category":"section"},{"location":"","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"TemporalNetworks.jl is a package that computes partitions of graphs/networks defined in spacetime. The networks are defined by a sequence Vector{Matrix{Float64}} of adjacency matrices. One can perform the following tasks:","category":"page"},{"location":"","page":"TemporalNetworks.jl","title":"TemporalNetworks.jl","text":"Compute spectral partitions of multiplex and nonmultiplex spacetime graphs using appropriate supra-Laplacians.\nUse the Sparse Eigenbasis Algorithm to disentagle multiple partition elements from eigenvectors of the supra-Laplacian.\nPlot networks, partitions and compute corresponding Cheeger ratios.\nCompute and plot partitions using Leiden, a modularity maximisation algorithm via the python package leidenalg.","category":"page"}]
}
